package ca.mcmaster.se2aa4.mazerunner;

import org.apache.commons.cli.*; // PMD false positive (UnnecessaryImport), Main needs to import this to use parsing
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public abstract class Main {

    private static final Logger logger = LogManager.getLogger();

    public static void main(String[] args) {
        
        if (logger.isInfoEnabled()) {
           logger.info("** Starting Maze Runner");         
        }
        CommandLineParser parser = new DefaultParser();

        CommandLine cmd = null;
        try {
            cmd = parser.parse(getParserOptions(), args);
            String filePath = cmd.getOptionValue('i');
            Maze maze = new Maze(filePath);

            if (cmd.getOptionValue("p") != null) {
                logger.info("Validating path");
                Path path = new Path(cmd.getOptionValue("p"));
                if (maze.validatePath(path)) {
                    System.out.println("correct path");
                } else {
                    System.out.println("incorrect path");
                }
            }
            
            else if (cmd.hasOption("baseline") & cmd.hasOption("method")) {
                String baseline = cmd.getOptionValue("baseline");
                String method = cmd.getOptionValue("method");
                System.out.println("Activating baseline using: " + baseline);
                System.out.println("Activating method using: " + method);
                
                // time spent loading maze
                long benchmarkStartTime = System.currentTimeMillis();
                new Maze(filePath);
                long benchmarkEndTime = System.currentTimeMillis();
                double benchmarkTime = benchmarkEndTime - benchmarkStartTime;

                // time spent exploring maze using -baseline
                long baselineStartTime = System.currentTimeMillis();
                Path baselinePath = solveMaze(baseline, maze);
                long baselineEndTime = System.currentTimeMillis();
                float baselineTime = (float) (baselineEndTime - baselineStartTime);

                
                // time spent exploring maze using -method
                long methodStartTime = System.currentTimeMillis();
                Path methodLinePath = solveMaze(method, maze);
                long methodEndTime = System.currentTimeMillis();
                float methodLineTime = (float) (methodEndTime - methodStartTime);

                // for the speed up path
                float speedUpPath = (float) baselinePath.getLength() / methodLinePath.getLength();

                // rounding to 2 decimal
                String formattedLoadTime = String.format("%.2f", benchmarkTime);
                String formattedBaselineTime = String.format("%.2f", baselineTime);
                String speedUp = String.format("%.2f", methodLineTime);
                String newSpeedUp = String.format("%.2f", speedUpPath);
                
                // printing stdout of loading file, solving maze using baseline and method, and speed up time
                System.out.println("Time spent loading file: " + formattedLoadTime + " milliseconds");
                System.out.println("Time spent solving maze baseline: " + formattedBaselineTime + " milliseconds");
                System.out.println("Time spent solving maze method: " + speedUp + " milliseconds");
                System.out.println("Speed up time is baseline/method ->  " + baselinePath.getLength() + "/" + methodLinePath.getLength() + " = " + newSpeedUp);
            }
            // only using baseline command
            else if (cmd.hasOption("baseline")) {
                String baseline = cmd.getOptionValue("baseline");
                
                // time spent loading maze
                long benchmarkStartTime = System.currentTimeMillis();
                new Maze(filePath);
                long benchmarkEndTime = System.currentTimeMillis();
                double benchmarkTime = benchmarkEndTime - benchmarkStartTime;

                // time spent exploring maze using -baseline
                long baselineStartTime = System.currentTimeMillis();
                solveMaze(baseline, maze);
                long baselineEndTime = System.currentTimeMillis();
                float baselineTime = (float) (baselineEndTime - baselineStartTime);
                
                // rounding to 2 decimal
                String formattedLoadTime = String.format("%.2f", benchmarkTime);
                String formattedBaselineTime = String.format("%.2f", baselineTime);
                
                // printing method
                System.out.println("Time spent loading file: " + formattedLoadTime + " milliseconds");
                System.out.println("Time spent solving maze baseline: " + formattedBaselineTime + " milliseconds");
            }

            else {
                String method = cmd.getOptionValue("method", "righthand");
                Path path = solveMaze(method, maze);
                System.out.println(path.getFactorizedForm());
            }
        } catch (Exception e) {
            System.err.println("MazeSolver failed.  Reason: " + e.getMessage());
            if (logger.isErrorEnabled()) {
                logger.error("MazeSolver failed.  Reason: " + e.getMessage());
                logger.error("PATH NOT COMPUTED");     
            }
        }
        if (logger.isInfoEnabled()) {
            logger.info("End of MazeRunner");         
        }
    }

    /**
     * Solve provided maze with specified method.
     *
     * @param method Method to solve maze with
     * @param maze Maze to solve
     * @return Maze solution path
     * @throws Exception If provided method does not exist
     */
    private static Path solveMaze(String method, Maze maze) throws Exception {
        MazeSolverFactory factory;
        switch (method) {
            case "righthand":
                factory = new RightHandSolverFactory();
                if (logger.isDebugEnabled()) {
                    logger.debug("RightHand algorithm chosen.");
                }
                break;
            case "tremaux":
                factory = new TremauxSolverFactory();
                if (logger.isDebugEnabled()) {
                    logger.debug("Tremaux algorithm chosen.");
                }
                break;
            case "bfs":
                factory = new BreadthFirstSearchSolverFactory();
                if (logger.isDebugEnabled()) {
                    logger.debug("Breadth First Search algorithm chosen.");
                }
                break;
            default:
                throw new Exception("Maze solving method '" + method + "' not supported.");
        }
        if (logger.isDebugEnabled()) {
            logger.info("Computing path");
        }
        MazeSolver solver = factory.createSolver();
        return solver.solve(maze);
    }

    /**
     * Get options for CLI parser.
     *
     * @return CLI parser options
     */
    private static Options getParserOptions() {
        Options options = new Options();

        Option fileOption = new Option("i", true, "File that contains maze");
        fileOption.setRequired(true);
        options.addOption(fileOption);

        options.addOption(new Option("p", true, "Path to be verified in maze"));
        options.addOption(new Option("method", true, "Specify which path computation algorithm will be used"));
        options.addOption(new Option("baseline", true, "Benchmark with algorithms"));

        return options;
    }
}

package ca.mcmaster.se2aa4.mazerunner;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

public class Maze {
    private static final Logger logger = LogManager.getLogger();

    private final List<List<Boolean>> maze = new ArrayList<>();

    private final Position start;
    private final Position end;

    /**
     * Initialize a Maze from a file path.
     *
     * @param filePath File path of the maze file
     * @throws Exception If maze cannot be read, or maze has no start or end
     */
     
    public Maze(String filePath) throws Exception {
        if (logger.isDebugEnabled()) {
            logger.debug("Reading the maze from file " + filePath);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                List<Boolean> newLine = new ArrayList<>();
                for (int idx = 0; idx < line.length(); idx++) {
                    if (line.charAt(idx) == '#') {
                        newLine.add(true);
                    } else if (line.charAt(idx) == ' ') {
                        newLine.add(false);
                    }
                }
                maze.add(newLine);
            }
        }
        start = findStart();
        end = findEnd();
    }

    /**
     * Find start position of the maze.
     *
     * @return The start position
     * @throws Exception If no valid start position exists
     */
    private Position findStart() throws Exception {
        for (int i = 0; i < maze.size(); i++) {
            Position pos = new Position(0, i);
            if (!isWall(pos)) {
                return pos;
            }
        }
        throw new Exception("Invalid maze (no start position available)");
    }

    /**
     * Find start end of the maze.
     *
     * @return The end position
     * @throws Exception If no valid end position exists
     */
    private Position findEnd() throws Exception {
        for (int i = 0; i < maze.size(); i++) {
            Position pos = new Position(maze.getFirst().size() - 1, i);
            if (!isWall(pos)) {
                return pos;
            }
        }
        throw new Exception("Invalid maze (no end position available)");
    }

    /**
     * Check if position of Maze is a wall.
     *
     * @param pos The position to check
     * @return If position is a wall
     */
    public Boolean isWall(Position pos) {
        return maze.get(pos.y()).get(pos.x());
    }

    /**
     * Get start position.
     *
     * @return Start position
     */
    public Position getStart() {
        return start;
    }

    /**
     * Get end position.
     *
     * @return End position
     */
    public Position getEnd() {
        return end;
    }

    /**
     * Get horizontal (X) size of Maze.
     *
     * @return Horizontal size
     */
    public int getSizeX() {
        return this.maze.getFirst().size();
    }

    /**
     * Get vertical (Y) size of Maze.
     *
     * @return Vertical size
     */
    public int getSizeY() {
        return this.maze.size();
    }

    /**
     * Check if path is valid for Maze.
     *
     * @param path The path to valid
     * @return If path is valid
     */
    public Boolean validatePath(Path path) {
        return validatePathDir(path, getStart(), Direction.RIGHT, getEnd()) || validatePathDir(path, getEnd(), Direction.LEFT, getStart());
    }

    /**
     * Check if path is valid from starting to end position.
     *
     * @param path Path
     * @param startPos Starting position
     * @param startDir Starting direction
     * @param endPos Ending position
     * @return If path is valid
     */
    private Boolean validatePathDir(Path path, Position startPos, Direction startDir, Position endPos) {
        Position pos = startPos;
        Direction dir = startDir;
        for (char c : path.getPathSteps()) {
            switch (c) {
                case 'F' -> {
                    pos = pos.move(dir);

                    if (pos.x() >= getSizeX() || pos.y() >= getSizeY() || pos.x() < 0 || pos.y() < 0) {
                        return false;
                    }
                    if (isWall(pos)) {
                        return false;
                    }
                }
                case 'R' -> dir = dir.turnRight();
                case 'L' -> dir = dir.turnLeft();

                default -> {
                    break;
                }
            }
            if (logger.isDebugEnabled()) {logger.debug("Current Position: " + pos);}
        }

        return pos.equals(endPos);
    }

    public boolean isValidPosition(Position pos) {
        return pos.x() >= 0 && pos.x() < getSizeX() &&
               pos.y() >= 0 && pos.y() < getSizeY() &&
               !isWall(pos);
    }
}

package ca.mcmaster.se2aa4.mazerunner;

public interface MazeSolver {
    /**
     * Solve maze and return path through maze.
     *
     * @param maze Maze to solve
     * @return Path that solves the provided maze
     */
    Path solve(Maze maze);
}

package ca.mcmaster.se2aa4.mazerunner;

public interface MazeSolverFactory {
    MazeSolver createSolver();
}

package ca.mcmaster.se2aa4.mazerunner;

public class Node {
    private Direction direction;
    private Position position;

    public Node(Direction direction, Position position) {
        this.direction = direction;
        this.position = position;
    }

    public Direction getDirection() {
        return this.direction;
    }

    public Position getPosition() {
        return this.position;
    }

}

package ca.mcmaster.se2aa4.mazerunner;

import java.util.ArrayList;
import java.util.List;

public class Path {
    private final List<Character> path = new ArrayList<>();

    /**
     * Initialize an empty Path.
     */
    public Path() {
        // empty constructor
    }

    public int getLength() {
        return path.size();
    }

    /**
     * Initialize path from a Path String.
     *
     * @param pathStr The Path String
     */
    public Path(String pathStr) {
        String expanded = expandFactorizedStringPath(pathStr);
        for (Character c : expanded.toCharArray()) {
            if (c != ' ') {
                if (c != 'F' && c != 'L' && c != 'R') {
                    throw new IllegalArgumentException("Instruction '" + c + "' is invalid. Must be 'F', 'L', or 'R'.");
                }
                addStep(c);
            }
        }
    }

    /**
     * Expand a factorized string path into a canonical one.
     *
     * @param path String path
     * @return Expanded string path
     */
    public String expandFactorizedStringPath(String path) {
        StringBuilder expanded = new StringBuilder();

        for (int i = 0; i < path.length(); i++) {
            if (!Character.isDigit(path.charAt(i))) {
                expanded.append(path.charAt(i));
            } else {
                int count = 0;
                int digit = 0;
                do {
                    count *= (int) Math.pow(10, digit++);
                    count += Character.getNumericValue(path.charAt(i++));
                } while (Character.isDigit(path.charAt(i)));

                String step = String.valueOf(path.charAt(i)).repeat(count);
                expanded.append(step);
            }
        }

        return expanded.toString();
    }

    /**
     * Get steps of Path.
     *
     * @return Chars of Path
     */
    public List<Character> getPathSteps() {
        return new ArrayList<>(this.path);
    }

    /**
     * Adds a step to the path.
     *
     * @param step The step that needs to be added.
     */
    public void addStep(Character step) {
        path.add(step);
    }

    /**
     * Generates the canonical form of the maze path.
     *
     * @return A string of the canonical form of a path.
     */
    public String getCanonicalForm() {
        StringBuilder sb = new StringBuilder();

        for (Character c : path) {
            if (sb.isEmpty() || sb.charAt(sb.length() - 1) == c) {
                sb.append(c);
            } else {
                sb.append(' ');
                sb.append(c);
            }
        }

        return sb.toString();
    }

    /**
     * Generates the factorized form of the maze path.
     *
     * @return A string of the factorized form of a path.
     */
    public String getFactorizedForm() {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < path.size(); i++) {
            Character current = path.get(i);
            int count = 0;
            while (i < path.size() && current.equals(path.get(i))) {
                count++;
                i++;
            }

            if (count == 1) {
                sb.append(current);
            } else {
                sb.append(count);
                sb.append(current);
            }

            if (i != path.size()) {
                sb.append(' ');
            }
            i--;
        }

        return sb.toString();
    }
}

package ca.mcmaster.se2aa4.mazerunner;

public record Position(int x, int y) {
    /**
     * Adds another position to this position and return the sum of both.
     *
     * @param other Other position
     * @return Sum of both positions
     */    
    public Position add(Position other) {
        return new Position(this.x + other.x, this.y + other.y);
    }

    public int getRow() {
        return this.y;
    }

    public int getColumn() {
        return this.x;
    }


    /**
     * Return the new position after moving in provided direction.
     *
     * @param direction Direction in which to move
     * @return The new position
     */
    public Position move(Direction direction) {
        switch (direction) {
            case UP -> {
                return this.add(new Position(0, -1));
            }
            case DOWN -> {
                return this.add(new Position(0, 1));
            }
            case LEFT -> {
                return this.add(new Position(-1, 0));
            }
            case RIGHT -> {
                return this.add(new Position(1, 0));
            }
            default -> {
                break;
            }
        }
        throw new IllegalStateException("Unexpected value: " + this);
    }

    @Override
    public String toString() {
        return "Position(" + this.x + "," + this.y + ")";
    }
}
package ca.mcmaster.se2aa4.mazerunner;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class RightHandSolver implements MazeSolver {
    private static final Logger logger = LogManager.getLogger();

    @Override
    public Path solve(Maze maze) {
        Path path = new Path();

        Position currentPos = maze.getStart();
        Direction dir = Direction.RIGHT;
        while (!currentPos.equals(maze.getEnd())) {
            if (!maze.isWall(currentPos.move(dir.turnRight()))) {
                // Turn right and move forward if not a wall
                dir = dir.turnRight();
                path.addStep('R');
                currentPos = currentPos.move(dir);
                path.addStep('F');
            } else {
                if (!maze.isWall(currentPos.move(dir))) {
                    // Go forward if not a wall
                    currentPos = currentPos.move(dir);
                    path.addStep('F');
                } else if (!maze.isWall(currentPos.move(dir.turnLeft()))) {
                    // Go left if not a wall
                    dir = dir.turnLeft();
                    path.addStep('L');
                    currentPos = currentPos.move(dir);
                    path.addStep('F');
                } else {
                    // Turn around
                    dir = dir.turnRight().turnRight();
                    path.addStep('R');
                    path.addStep('R');
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug("Current Position: " + currentPos.toString() + "\n Current Path: " + path.getCanonicalForm());
            }
        }

        return path;
    }
}

package ca.mcmaster.se2aa4.mazerunner;

public class RightHandSolverFactory implements MazeSolverFactory {
    
    @Override
    public MazeSolver createSolver() {
        return new RightHandSolver();
    }
    
}

package ca.mcmaster.se2aa4.mazerunner;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class TremauxSolver implements MazeSolver {
    private static final Logger logger = LogManager.getLogger();
    private int[][] marks;
    private Maze maze;

    @Override
    public Path solve(Maze maze) {
        this.maze = maze;
        marks = new int[maze.getSizeY()][maze.getSizeX()];
        logger.debug("Marking entrances...");
        markEntrances();
        logger.debug("Tracing path...");
        return tracePath();
    }

    /**
     * Mark entrances in marks 2D array.
     */
    private void markEntrances() {
        Position currentPos = maze.getStart();
        Position previousPos = null;
        marks[currentPos.y()][currentPos.x()] = 1;

        while (!currentPos.equals(maze.getEnd())) {
            List<Position> neighbors = getMazeNeighbors(currentPos);
            neighbors.remove(previousPos);

            Position newPos;
            if (neighbors.isEmpty()) {
                // Go back
                newPos = previousPos;
            } else if (neighbors.size() == 1) {
                // Move forward
                newPos = neighbors.getFirst();
            } else {
                // At junction
                Position fewestMarks = pickNeighbor(neighbors);
                if (marks[previousPos.y()][previousPos.x()] != 0 && marks[fewestMarks.y()][fewestMarks.x()] == 0) {
                    newPos = fewestMarks;
                } else if (marks[previousPos.y()][previousPos.x()] != 2) {
                    newPos = previousPos;
                } else {
                    newPos = fewestMarks;
                }
            }

            if (previousPos != null && getMazeNeighbors(previousPos).size() > 2) {
                marks[currentPos.y()][currentPos.x()] += 1;
            } else if (getMazeNeighbors(newPos).size() > 2) {
                marks[currentPos.y()][currentPos.x()] += 1;
            }

            previousPos = currentPos;
            currentPos = newPos;
        }
        marks[maze.getEnd().y()][maze.getEnd().x()] = 1;
    }

    /**
     * Chose a viable neighbor by sorting the neighbors by the number of
     * marks and picking the first.
     *
     * @param neighbors Neighbors to chose from
     * @return Chosen neighbor
     */
    private Position pickNeighbor(List<Position> neighbors) {
        neighbors.sort(Comparator.comparingInt(pos -> marks[pos.y()][pos.x()]));
        return neighbors.getFirst();
    }

    /**
     * Get list of possible valid neighbors of position.
     *
     * @param pos Position to get neighbors of
     * @return List of neighbors
     */
    private List<Position> getMazeNeighbors(Position pos) {
        List<Position> neighbors = new ArrayList<>();

        Position left = pos.add(new Position(-1, 0));
        if (left.x() >= 0 && !maze.isWall(left)) {neighbors.add(left);}

        Position right = pos.add(new Position(1, 0));
        if (right.x() < maze.getSizeX() && !maze.isWall(right)) {neighbors.add(right);}

        Position up = pos.add(new Position(0, -1));
        if (up.y() >= 0 && !maze.isWall(up)) {neighbors.add(up);}

        Position down = pos.add(new Position(0, 1));
        if (down.y() < maze.getSizeY() && !maze.isWall(down)) {neighbors.add(down);}

        return neighbors;
    }

    /**
     * Create path from start to end using marks.
     *
     * @return Path from start to end
     */
    private Path tracePath() {
        Path path = new Path();

        Direction dir = Direction.RIGHT;
        Position pos = maze.getStart();

        while (!pos.equals(maze.getEnd())) {
            Position rightPos = pos.move(dir.turnRight());
            Position leftPos = pos.move(dir.turnLeft());
            Position forwardPos = pos.move(dir);
            if (isInBounds(rightPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(rightPos) && marks[rightPos.y()][rightPos.x()] == 1) {
                path.addStep('R');
                path.addStep('F');
                dir = dir.turnRight();
                pos = rightPos;
            } else if (isInBounds(leftPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(leftPos) && marks[leftPos.y()][leftPos.x()] == 1) {
                path.addStep('L');
                path.addStep('F');
                dir = dir.turnLeft();
                pos = leftPos;
            } else if (isInBounds(forwardPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(forwardPos) && marks[forwardPos.y()][forwardPos.x()] == 1) {
                path.addStep('F');
                pos = forwardPos;
            } else {
                if (isInBounds(rightPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(rightPos) && marks[rightPos.y()][rightPos.x()] == 0) {
                    path.addStep('R');
                    path.addStep('F');
                    dir = dir.turnRight();
                    pos = rightPos;
                } else if (isInBounds(leftPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(leftPos) && marks[leftPos.y()][leftPos.x()] == 0) {
                    path.addStep('L');
                    path.addStep('F');
                    dir = dir.turnLeft();
                    pos = leftPos;
                } else if (isInBounds(forwardPos, maze.getSizeX(), maze.getSizeY()) && !maze.isWall(forwardPos) && marks[forwardPos.y()][forwardPos.x()] == 0) {
                    path.addStep('F');
                    pos = forwardPos;
                } else {
                    throw new RuntimeException("Invalid maze.");
                }
            }
        }


        return path;
    }

    /**
     * Check if position is in the maze bounds.
     *
     * @param position Position to validate
     * @param sizeX    Maze horizontal (X) size
     * @param sizeY    Maze vertical (Y) size
     * @return If position is in bounds
     */
    private boolean isInBounds(Position position, int sizeX, int sizeY) {
        return position.x() >= 0 && position.x() < sizeX && position.y() >= 0 && position.y() < sizeY;
    }
}

package ca.mcmaster.se2aa4.mazerunner;

public class TremauxSolverFactory implements MazeSolverFactory {
    @Override
    public MazeSolver createSolver() {
        return new TremauxSolver();
    }
}


package ca.mcmaster.se2aa4.mazerunner;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class BreadthFirstSearchSolver implements MazeSolver {

    @Override
    public Path solve(Maze maze) {
        Queue<Node> queue = new LinkedList<>();
        boolean[][] visited = new boolean[maze.getSizeY()][maze.getSizeX()];
        HashMap<Position, Node> newMap = new HashMap<>();
        Position start = maze.getStart();
        Node startNode = new Node(Direction.RIGHT, start);
        Node endNode = new Node(Direction.RIGHT, start);

        queue.add(startNode);
        visited[start.getRow()][start.getColumn()] = true;
        newMap.put(startNode.getPosition(), null);

        while (!queue.isEmpty()) {
            Node current = queue.remove();

            if (current.getPosition().equals(maze.getEnd())) {
                endNode = current;
                break;
            }

            for (Direction direction : Direction.values()) {
                Position next = current.getPosition().move(direction);

                if (maze.isValidPosition(next) && !visited[next.getRow()][next.getColumn()] && !maze.isWall(next)) {
                    Node nextNode = new Node(direction, next);
                    queue.add(nextNode);
                    visited[next.getRow()][next.getColumn()] = true;
                    newMap.put(next, current);
                }
            }

        }
        // for getting previous
        List<Node> list = new ArrayList<>();
        Node prev = newMap.get(maze.getEnd());
        list.add(endNode);
        while (prev != null) {
            list.add(prev);
            prev = newMap.get(prev.getPosition());
        }

        Path path = new Path();
        list = list.reversed();
        for (int i = 0; i < list.size() - 1; i++) {
            path = getPath(list.get(i), list.get(i + 1), path);
        }
        return path;
    }

    private Path getPath(Node first, Node second, Path previousPath) {
        if (first.getDirection() == second.getDirection()) {
            previousPath.addStep('F');
        }
    
        else if (second.getDirection() == first.getDirection().turnLeft()) { // might have to fix that
            previousPath.addStep('L');
            previousPath.addStep('F');
        }

        else if (second.getDirection() == first.getDirection().turnRight()) {
            previousPath.addStep('R');
            previousPath.addStep('F');
        }
        return previousPath;
    }
}

package ca.mcmaster.se2aa4.mazerunner;

public class BreadthFirstSearchSolverFactory implements MazeSolverFactory {
    
    @Override
    public MazeSolver createSolver() {
        return new BreadthFirstSearchSolver();
    }
    
}

package ca.mcmaster.se2aa4.mazerunner;

public enum Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT;

    /**
     * Get the direction to the right of the current one.
     *
     * @return The direction to the right.
     */
    public Direction turnRight() {
        switch (this) {
            case UP -> {
                return RIGHT;
            }
            case DOWN -> {
                return LEFT;
            }
            case LEFT -> {
                return UP;
            }
            case RIGHT -> {
                return DOWN;
            }
            default -> {
                break;
            }
        
        }
        throw new IllegalStateException("Unexpected value: " + this);
    }

    /**
     * Get the direction to the left of the current one.
     *
     * @return The direction to the left.
     */
    public Direction turnLeft() {
        switch (this) {
            case UP -> {
                return LEFT;
            }
            case DOWN -> {
                return RIGHT;
            }
            case LEFT -> {
                return DOWN;
            }
            case RIGHT -> {
                return UP;
            }
            default -> {
                break;
            }
        }
        throw new IllegalStateException("Unexpected value: " + this);
    }
}







